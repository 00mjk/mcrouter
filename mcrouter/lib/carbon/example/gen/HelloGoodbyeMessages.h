/*
 *  Copyright (c) 2017-present, Facebook, Inc.
 *
 *  This source code is licensed under the MIT license found in the LICENSE
 *  file in the root directory of this source tree.
 *
 */

/*
 *  THIS FILE IS AUTOGENERATED. DO NOT MODIFY IT; ALL CHANGES WILL BE LOST IN
 *  VAIN.
 *
 *  @generated
 */
#pragma once

#include <memory>
#include <string>
#include <utility>

#include <folly/Optional.h>
#include <folly/io/IOBuf.h>
#include <mcrouter/lib/carbon/CarbonProtocolReader.h>
#include <mcrouter/lib/carbon/CommonSerializationTraits.h>
#include <mcrouter/lib/carbon/Keys.h>
#include <mcrouter/lib/carbon/ReplyCommon.h>
#include <mcrouter/lib/carbon/RequestCommon.h>
#include <mcrouter/lib/carbon/RequestReplyUtil.h>
#include <mcrouter/lib/carbon/Result.h>
#include <mcrouter/lib/carbon/TypeList.h>
#include <mcrouter/lib/carbon/Variant.h>

#include "mcrouter/lib/carbon/example/gen/gen-cpp2/HelloGoodbye_types.h"

#include "mcrouter/lib/network/gen/CommonMessages.h"

namespace hellogoodbye {

class HelloReply;

class HelloRequest : public carbon::RequestCommon {
 public:
  using reply_type = HelloReply;

  static constexpr size_t typeId = 65;
  static constexpr const char* name = "hello";

  HelloRequest() = default;
  HelloRequest(const HelloRequest&) = default;
  HelloRequest& operator=(const HelloRequest&) = default;
  HelloRequest(HelloRequest&&) = default;
  HelloRequest& operator=(HelloRequest&&) = default;
  explicit HelloRequest(folly::StringPiece sp) {
    underlyingThriftStruct_.key = sp;
  }
  explicit HelloRequest(folly::IOBuf&& carbonKey) {
    underlyingThriftStruct_.key = std::move(carbonKey);
  }

  const carbon::Keys<folly::IOBuf>& key() const {
    return underlyingThriftStruct_.key;
  }
  carbon::Keys<folly::IOBuf>& key() {
    markBufferAsDirty();
    return underlyingThriftStruct_.key;
  }
  FOLLY_ERASE ::apache::thrift::field_ref<const carbon::Keys<folly::IOBuf>&>
   key_ref() const& {
    return underlyingThriftStruct_.key_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<carbon::Keys<folly::IOBuf>&>
   key_ref() & {
    return underlyingThriftStruct_.key_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<carbon::Keys<folly::IOBuf>&&>
   key_ref() && {
    return std::move(underlyingThriftStruct_).key_ref();
  }
  
  uint64_t shardId() const {
    return underlyingThriftStruct_.shardId;
  }
  uint64_t& shardId() {
    markBufferAsDirty();
    return underlyingThriftStruct_.shardId;
  }
  FOLLY_ERASE ::apache::thrift::field_ref<const uint64_t&>
   shardId_ref() const& {
    return underlyingThriftStruct_.shardId_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<uint64_t&>
   shardId_ref() & {
    return underlyingThriftStruct_.shardId_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<uint64_t&&>
   shardId_ref() && {
    return std::move(underlyingThriftStruct_).shardId_ref();
  }
  
  uint64_t deadlineMs() const {
    return underlyingThriftStruct_.deadlineMs;
  }
  uint64_t& deadlineMs() {
    markBufferAsDirty();
    return underlyingThriftStruct_.deadlineMs;
  }
  FOLLY_ERASE ::apache::thrift::field_ref<const uint64_t&>
   deadlineMs_ref() const& {
    return underlyingThriftStruct_.deadlineMs_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<uint64_t&>
   deadlineMs_ref() & {
    return underlyingThriftStruct_.deadlineMs_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<uint64_t&&>
   deadlineMs_ref() && {
    return std::move(underlyingThriftStruct_).deadlineMs_ref();
  }
  
  const std::string& message() const {
    return underlyingThriftStruct_.message;
  }
  std::string& message() {
    markBufferAsDirty();
    return underlyingThriftStruct_.message;
  }
  FOLLY_ERASE ::apache::thrift::field_ref<const std::string&>
   message_ref() const& {
    return underlyingThriftStruct_.message_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<std::string&>
   message_ref() & {
    return underlyingThriftStruct_.message_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<std::string&&>
   message_ref() && {
    return std::move(underlyingThriftStruct_).message_ref();
  }
  
  const hellogoodbye::thrift::HelloRequest& getThriftStruct() const {
    return underlyingThriftStruct_;
  }
  hellogoodbye::thrift::HelloRequest& getThriftStruct() {
    markBufferAsDirty();
    return underlyingThriftStruct_;
  }

  template <class Writer>
  void serialize(Writer&& writer) const;

  void deserialize(carbon::CarbonProtocolReader& reader);

  template <class V>
  void visitFields(V&& v);
  template <class V>
  void visitFields(V&& v) const;

  // Methods for Thrift interoperability, note that the methods work with Thrift
  // protocols and not Carbon protocol.
  void __clear() {
    underlyingThriftStruct_.__clear();
  }
  template <class Protocol>
  uint32_t write(Protocol* protocol) const {
    return underlyingThriftStruct_.write(protocol);
  }
  template <class Protocol>
  uint32_t serializedSize(Protocol* protocol) const {
    return underlyingThriftStruct_.serializedSize(protocol);
  }
  template <class Protocol>
  uint32_t serializedSizeZC(Protocol* protocol) const {
    return underlyingThriftStruct_.serializedSizeZC(protocol);
  }
 private:
  template <class Protocol>
  void readNoXfer(Protocol* protocol) {
    underlyingThriftStruct_.read(protocol);
  }

  friend class apache::thrift::Cpp2Ops<HelloRequest>;

 private:
  struct __isset {
    bool key;
    bool shardId;
    bool deadlineMs;
    bool message;
  } __isset = {};

  hellogoodbye::thrift::HelloRequest underlyingThriftStruct_;
};

class HelloReply : public carbon::ReplyCommon {
 public:

  static constexpr size_t typeId = 66;

  HelloReply() = default;
  HelloReply(const HelloReply&) = default;
  HelloReply& operator=(const HelloReply&) = default;
  HelloReply(HelloReply&&) = default;
  HelloReply& operator=(HelloReply&&) = default;
  explicit HelloReply(carbon::Result carbonResult) {
    underlyingThriftStruct_.result = carbonResult;
  }

  carbon::Result result() const {
    return underlyingThriftStruct_.result;
  }
  carbon::Result& result() {
    return underlyingThriftStruct_.result;
  }
  FOLLY_ERASE ::apache::thrift::field_ref<const carbon::Result&>
   result_ref() const& {
    return underlyingThriftStruct_.result_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<carbon::Result&>
   result_ref() & {
    return underlyingThriftStruct_.result_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<carbon::Result&&>
   result_ref() && {
    return std::move(underlyingThriftStruct_).result_ref();
  }
  
  const std::string& message() const {
    return underlyingThriftStruct_.message;
  }
  std::string& message() {
    return underlyingThriftStruct_.message;
  }
  FOLLY_ERASE ::apache::thrift::field_ref<const std::string&>
   message_ref() const& {
    return underlyingThriftStruct_.message_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<std::string&>
   message_ref() & {
    return underlyingThriftStruct_.message_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<std::string&&>
   message_ref() && {
    return std::move(underlyingThriftStruct_).message_ref();
  }
  
  const hellogoodbye::thrift::HelloReply& getThriftStruct() const {
    return underlyingThriftStruct_;
  }
  hellogoodbye::thrift::HelloReply& getThriftStruct() {
    return underlyingThriftStruct_;
  }

  template <class Writer>
  void serialize(Writer&& writer) const;

  void deserialize(carbon::CarbonProtocolReader& reader);

  template <class V>
  void visitFields(V&& v);
  template <class V>
  void visitFields(V&& v) const;

  // Methods for Thrift interoperability, note that the methods work with Thrift
  // protocols and not Carbon protocol.
  void __clear() {
    underlyingThriftStruct_.__clear();
  }
  template <class Protocol>
  uint32_t write(Protocol* protocol) const {
    return underlyingThriftStruct_.write(protocol);
  }
  template <class Protocol>
  uint32_t serializedSize(Protocol* protocol) const {
    return underlyingThriftStruct_.serializedSize(protocol);
  }
  template <class Protocol>
  uint32_t serializedSizeZC(Protocol* protocol) const {
    return underlyingThriftStruct_.serializedSizeZC(protocol);
  }
 private:
  template <class Protocol>
  void readNoXfer(Protocol* protocol) {
    underlyingThriftStruct_.read(protocol);
  }

  friend class apache::thrift::Cpp2Ops<HelloReply>;

 private:
  struct __isset {
    bool result;
    bool message;
  } __isset = {};

  hellogoodbye::thrift::HelloReply underlyingThriftStruct_;
};

class GoodbyeReply;

class GoodbyeRequest : public carbon::RequestCommon {
 public:
  using reply_type = GoodbyeReply;

  static constexpr size_t typeId = 67;
  static constexpr const char* name = "goodbye";

  GoodbyeRequest() = default;
  GoodbyeRequest(const GoodbyeRequest&) = default;
  GoodbyeRequest& operator=(const GoodbyeRequest&) = default;
  GoodbyeRequest(GoodbyeRequest&&) = default;
  GoodbyeRequest& operator=(GoodbyeRequest&&) = default;
  explicit GoodbyeRequest(folly::StringPiece sp) {
    underlyingThriftStruct_.key = sp;
  }
  explicit GoodbyeRequest(folly::IOBuf&& carbonKey) {
    underlyingThriftStruct_.key = std::move(carbonKey);
  }

  const carbon::Keys<folly::IOBuf>& key() const {
    return underlyingThriftStruct_.key;
  }
  carbon::Keys<folly::IOBuf>& key() {
    markBufferAsDirty();
    return underlyingThriftStruct_.key;
  }
  FOLLY_ERASE ::apache::thrift::field_ref<const carbon::Keys<folly::IOBuf>&>
   key_ref() const& {
    return underlyingThriftStruct_.key_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<carbon::Keys<folly::IOBuf>&>
   key_ref() & {
    return underlyingThriftStruct_.key_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<carbon::Keys<folly::IOBuf>&&>
   key_ref() && {
    return std::move(underlyingThriftStruct_).key_ref();
  }
  
  uint64_t shardId() const {
    return underlyingThriftStruct_.shardId;
  }
  uint64_t& shardId() {
    markBufferAsDirty();
    return underlyingThriftStruct_.shardId;
  }
  FOLLY_ERASE ::apache::thrift::field_ref<const uint64_t&>
   shardId_ref() const& {
    return underlyingThriftStruct_.shardId_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<uint64_t&>
   shardId_ref() & {
    return underlyingThriftStruct_.shardId_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<uint64_t&&>
   shardId_ref() && {
    return std::move(underlyingThriftStruct_).shardId_ref();
  }
  
  const hellogoodbye::thrift::GoodbyeRequest& getThriftStruct() const {
    return underlyingThriftStruct_;
  }
  hellogoodbye::thrift::GoodbyeRequest& getThriftStruct() {
    markBufferAsDirty();
    return underlyingThriftStruct_;
  }

  template <class Writer>
  void serialize(Writer&& writer) const;

  void deserialize(carbon::CarbonProtocolReader& reader);

  template <class V>
  void visitFields(V&& v);
  template <class V>
  void visitFields(V&& v) const;

  // Methods for Thrift interoperability, note that the methods work with Thrift
  // protocols and not Carbon protocol.
  void __clear() {
    underlyingThriftStruct_.__clear();
  }
  template <class Protocol>
  uint32_t write(Protocol* protocol) const {
    return underlyingThriftStruct_.write(protocol);
  }
  template <class Protocol>
  uint32_t serializedSize(Protocol* protocol) const {
    return underlyingThriftStruct_.serializedSize(protocol);
  }
  template <class Protocol>
  uint32_t serializedSizeZC(Protocol* protocol) const {
    return underlyingThriftStruct_.serializedSizeZC(protocol);
  }
 private:
  template <class Protocol>
  void readNoXfer(Protocol* protocol) {
    underlyingThriftStruct_.read(protocol);
  }

  friend class apache::thrift::Cpp2Ops<GoodbyeRequest>;

 private:
  struct __isset {
    bool key;
    bool shardId;
  } __isset = {};

  hellogoodbye::thrift::GoodbyeRequest underlyingThriftStruct_;
};

class GoodbyeReply : public carbon::ReplyCommon {
 public:

  static constexpr size_t typeId = 68;

  GoodbyeReply() = default;
  GoodbyeReply(const GoodbyeReply&) = default;
  GoodbyeReply& operator=(const GoodbyeReply&) = default;
  GoodbyeReply(GoodbyeReply&&) = default;
  GoodbyeReply& operator=(GoodbyeReply&&) = default;
  explicit GoodbyeReply(carbon::Result carbonResult) {
    underlyingThriftStruct_.result = carbonResult;
  }

  carbon::Result result() const {
    return underlyingThriftStruct_.result;
  }
  carbon::Result& result() {
    return underlyingThriftStruct_.result;
  }
  FOLLY_ERASE ::apache::thrift::field_ref<const carbon::Result&>
   result_ref() const& {
    return underlyingThriftStruct_.result_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<carbon::Result&>
   result_ref() & {
    return underlyingThriftStruct_.result_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<carbon::Result&&>
   result_ref() && {
    return std::move(underlyingThriftStruct_).result_ref();
  }
  
  const std::string& message() const {
    return underlyingThriftStruct_.message;
  }
  std::string& message() {
    return underlyingThriftStruct_.message;
  }
  FOLLY_ERASE ::apache::thrift::field_ref<const std::string&>
   message_ref() const& {
    return underlyingThriftStruct_.message_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<std::string&>
   message_ref() & {
    return underlyingThriftStruct_.message_ref();
  }
  FOLLY_ERASE ::apache::thrift::field_ref<std::string&&>
   message_ref() && {
    return std::move(underlyingThriftStruct_).message_ref();
  }
  
  const hellogoodbye::thrift::GoodbyeReply& getThriftStruct() const {
    return underlyingThriftStruct_;
  }
  hellogoodbye::thrift::GoodbyeReply& getThriftStruct() {
    return underlyingThriftStruct_;
  }

  template <class Writer>
  void serialize(Writer&& writer) const;

  void deserialize(carbon::CarbonProtocolReader& reader);

  template <class V>
  void visitFields(V&& v);
  template <class V>
  void visitFields(V&& v) const;

  // Methods for Thrift interoperability, note that the methods work with Thrift
  // protocols and not Carbon protocol.
  void __clear() {
    underlyingThriftStruct_.__clear();
  }
  template <class Protocol>
  uint32_t write(Protocol* protocol) const {
    return underlyingThriftStruct_.write(protocol);
  }
  template <class Protocol>
  uint32_t serializedSize(Protocol* protocol) const {
    return underlyingThriftStruct_.serializedSize(protocol);
  }
  template <class Protocol>
  uint32_t serializedSizeZC(Protocol* protocol) const {
    return underlyingThriftStruct_.serializedSizeZC(protocol);
  }
 private:
  template <class Protocol>
  void readNoXfer(Protocol* protocol) {
    underlyingThriftStruct_.read(protocol);
  }

  friend class apache::thrift::Cpp2Ops<GoodbyeReply>;

 private:
  struct __isset {
    bool result;
    bool message;
  } __isset = {};

  hellogoodbye::thrift::GoodbyeReply underlyingThriftStruct_;
};
} // namespace hellogoodbye

#include "HelloGoodbyeMessages-inl.h"
